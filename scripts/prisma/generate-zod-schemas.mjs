import pkg from '@prisma/internals'
import * as fs from 'fs'
import * as path from 'path'

const { getDMMF } = pkg

async function generateZodSchemas() {
  try {
    // Path to your Prisma schema file
    const prismaSchemaPath = path.join(process.cwd(), 'prisma/schema.prisma')
    const prismaSchema = fs.readFileSync(prismaSchemaPath, 'utf-8')

    // Get Prisma DMMF (Data Model Meta Format)
    const dmmf = await getDMMF({ datamodel: prismaSchema })

    let output = `// Auto-generated Zod schemas from Prisma schema
import { z } from 'zod';\n\n`

    // Generate enums
    const enums = dmmf.datamodel.enums
    for (const enumItem of enums) {
      const enumValues = enumItem.values.map((v) => `'${v.name}'`).join(', ')
      output += `export const ${enumItem.name}Enum = z.enum([${enumValues}]);\n`
      output += `export type ${enumItem.name} = z.infer<typeof ${enumItem.name}Enum>;\n\n`
    }

    // Generate model schemas
    const models = dmmf.datamodel.models
    for (const model of models) {
      // Main model schema with all fields
      output += `export const ${model.name}Schema = z.object({\n`

      for (const field of model.fields) {
        output += `  ${field.name}: `

        // Handle field types
        if (field.kind === 'scalar') {
          switch (field.type) {
            case 'String':
              output += field.isRequired ? `z.string()` : `z.string().nullable()`

              // Add special validation for email fields
              if (field.name.toLowerCase().includes('email')) {
                output += `.email()`
              }

              // Add UUID validation for IDs
              if (field.name === 'id' || field.name.endsWith('Id')) {
                output += `.uuid()`
              }
              break
            case 'Int':
              output += field.isRequired ? `z.number().int()` : `z.number().int().nullable()`
              break
            case 'Float':
              output += field.isRequired ? `z.number()` : `z.number().nullable()`
              break
            case 'Boolean':
              output += field.isRequired ? `z.boolean()` : `z.boolean().nullable()`
              break
            case 'DateTime':
              output += field.isRequired ? `z.date()` : `z.date().nullable()`
              break
            default:
              output += field.isRequired ? `z.any()` : `z.any().nullable()`
          }
        } else if (field.kind === 'enum') {
          output += field.isRequired ? `${field.type}Enum` : `${field.type}Enum.nullable()`
        } else if (field.kind === 'object') {
          // Relations are typically handled separately
          output += `z.string().uuid()`
        }

        output += ',\n'
      }

      output += `});\n\n`
      output += `export type ${model.name} = z.infer<typeof ${model.name}Schema>;\n\n`

      // Create schema for inputs (creation)
      output += `export const Create${model.name}Schema = z.object({\n`

      for (const field of model.fields) {
        // Skip auto-generated fields, timestamps, and relation fields
        const isAutoGeneratedId = field.isId && field.hasDefaultValue
        const isTimestamp = ['createdAt', 'updatedAt', 'created_at', 'updated_at'].includes(
          field.name,
        )

        if (isAutoGeneratedId || isTimestamp || field.kind === 'object') {
          continue
        }

        output += `  ${field.name}: `

        // Handle field types similarly to above, but with appropriate validations for inputs
        if (field.kind === 'scalar') {
          switch (field.type) {
            case 'String':
              output += field.isRequired ? `z.string()` : `z.string().optional()`

              if (field.name.toLowerCase().includes('email')) {
                output += `.email('Invalid email address')`
              }

              if (field.name === 'password' || field.name.includes('password')) {
                output += `.min(8, 'Password must be at least 8 characters')`
              }

              if (field.name === 'name') {
                output += `.min(1, 'Name is required')`
              }
              break
            case 'Int':
              output += field.isRequired ? `z.number().int()` : `z.number().int().optional()`
              break
            case 'Float':
              output += field.isRequired ? `z.number()` : `z.number().optional()`

              if (field.name === 'weight') {
                output += `.positive('Weight must be a positive number')`
              }
              break
            case 'Boolean':
              output += field.isRequired ? `z.boolean()` : `z.boolean().optional()`
              break
            case 'DateTime':
              output += field.isRequired ? `z.date()` : `z.date().optional()`
              break
            default:
              output += field.isRequired ? `z.any()` : `z.any().optional()`
          }
        } else if (field.kind === 'enum') {
          output += field.isRequired ? `${field.type}Enum` : `${field.type}Enum.optional()`
        }

        output += ',\n'
      }

      output += `});\n\n`
      output += `export type Create${model.name} = z.infer<typeof Create${model.name}Schema>;\n\n`

      // Create schema for updates (all fields optional)
      output += `export const Update${model.name}Schema = Create${model.name}Schema.partial();\n`
      output += `export type Update${model.name} = z.infer<typeof Update${model.name}Schema>;\n\n`
    }

    // Write to file
    const outputDir = path.join(process.cwd(), 'src/schemas')
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true })
    }

    const outputPath = path.join(outputDir, 'index.ts')
    fs.writeFileSync(outputPath, output)

    console.info(`Zod schemas generated successfully at ${outputPath}`)
  } catch (error) {
    console.error('Error generating Zod schemas:', error)
  }
}

// Run the generator
generateZodSchemas().catch(console.error)
